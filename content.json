{"pages":[{"title":"About","text":"안녕하세요, Techlog를 운영하고 있는 최용득 입니다.삶을 살아가다 보면 좋아서 시작한 일들이 어느 순간부터 재미없고 귀찮아지는 순간들이 있습니다.저에게 있어서 개발자의 삶 역시 그런 순간들을 종종 마주하게 되는데요, 그런 순간들이 싫지만 동시에 제 삶을 돌아볼 수 있는 계기가 되는 것 같습니다.지금까지도 그랬지만 앞으로도 계속해서 개발 일을 좋아하고, 때로는 슬럼프도 마주하면서 자신을 되돌아보는 그런 삶을 살려고 노력하고 있습니다. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"5분안에 Node.js 로컬호스트에 HTTPS 적용하기","text":"들어가는 글,지난번에 올린 HTTPS의 기본 개념에 이어 이번에는 https를 로컬호스트에 적용하는 방법에 대해 알아보겠습니다.최근 개발하는 서비스에서 중요한 유저 정보 및 카드 정보 등을 위해 https를 개발해야 하는 상황이 생겼습니다.보통은 node.js서버에 https를 적용하지만 역시 나 개발을 하려면 로컬 적용이 불가피합니다.일반적인 웹사이트 또는 서버에서 사용할 https에서는 Certification Authority(CA)가 필요하지만, 본 포스트에서는 임의로 certificate을 발급하는 방법과 trust 방법에 대해 알아보겠습니다.Root SSL Certificateopenssl 을 이용하여 우선 rootCA.key 를 생성하여야 합니다.아래의 커맨드를 입력하여 생성 가능하며, 생성도중에 passphrase를 물어보게 되는데 추후 key를 사용할때마다 입력되어야 하는 값이므로 잊어버리지 않도록 합니다..openssl genrsa -des3 -out rootCA.key 2048passphrase에 대한 자세한 내용위에서 생성된 key를 이용하여 이번에는 pem파일을 만들어줍니다. 아래에는 1024일동안 사용가능하며 원하는 기간만큼 숫자를 조정하면 됩니다.openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.pemCertificate Trust 처리임의로 생성된 certificate이기 때문에 브라우저에서는 믿을 수 없다고 처리됩니다. 따라서 호스트역할을 하는 (여기서는 Mac)서버에서 trust 처리를 해주어야 합니다.mac의 keychain access에서 방금 생성한 certificate을 찾아 always trust 처리를 해줍니다.keychain access여기에 생성한 certificate을 import 해준다면 위와 같이 등록이 되며, 더블클릭 후 trust에서 always trust로 처리 합니다.자 이제 거의 다 왔습니다.사실 이 상태로 certificate을 서버에 적용하여 돌려보면 HTTPS로 동작은 합니다만 여전히 브라우저에서는 Not Secure라고 표시됩니다.로컬에서 사용할 수 있도록 domain 설정하기방금전 certificate을 생성하였던 디렉토리에서 아래와 같은 파일을 생성합니다.cnf파일은 키 생성시 입력하였던 옵션값을 파일로 만들어 매번 생성 시 일일이 값을 입력하지 않도록 해줍니다.server.csr.cnf1234567891011121314[req]default_bits = 2048prompt = nodefault_md = sha256distinguished_name = dn[dn]C=USST=StateNameL=CityNameO=OrganizationNameOU=OrganizationUnitNameemailAddress=helloworld@gililab.comCN = localhostv3.ext1234567authorityKeyIdentifier=keyid,issuerbasicConstraints=CA:FALSEkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEnciphermentsubjectAltName = @alt_names[alt_names]DNS.1 = localhost생성이 완료되었다면 아래의 커맨드로 server.key와 crt파일을 생성합니다.openssl req -new -sha256 -nodes -out server.csr -newkey rsa:2048 -keyout server.key -config &lt;( cat server.csr.cnf )openssl x509 -req -in server.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out server.crt -days 500 -sha256 -extfile v3.ext생성된 certificate node.js 서버에 적용하기생성된 server.key와 server.crt파일을 프로젝트 폴더에 위치 시킵니다.저는 프로젝트 폴더 하위에 private 이라는 폴더를 생성하여 server.key와 server.crt파일을 옮겨 넣었습니다.이제 ssl 데이터를 가지고 있는 config 파일을 생성하여 줍니다.ssl-config.js12345const path = require('path');const fs = require('fs'); exports.privateKey = fs.readFileSync(path.join(__dirname, '../private/server.key')).toString();exports.certificate = fs.readFileSync(path.join(__dirname, '../private/server.crt')).toString();시스템마다 다르겠지만 서버의 호스팅 옵션값을 가지고 있는 파일에 아래와 같이 적용합니다.loopback framework을 사용하는 저 같은 경우는 config.local.js 파일에 적용하였습니다.config.local.js123456{ restApiRoot: '/api', host: process.env.HOST || '0.0.0.0', port: process.env.PORT || 80, url: 'https://localhost',}마지막으로 server.js에 https를 적용시켜줍니다.!server.js12345678910111213141516171819202122232425...const https = require('https');const sslConfig = require('../config/ssl-config');...const options = { key: sslConfig.privateKey, cert: sslConfig.certificate, passphrase: 'abcd' // certificate을 생성하면서 입력하였던 passphrase 값};...const app = module.exports;app.start = function () { // start the web server const server = https.createServer(options, app); return server.listen(app.get('port'), () =&gt; { app.emit('started'); const baseUrl = app.get('url') + ':' + app.get('port'); console.info('Web server listening at: %s', baseUrl); if (app.get('loopback-component-explorer')) { const explorerPath = app.get('loopback-component-explorer').mountPath; console.info('Browse your REST API at %s%s', baseUrl, explorerPath); } });};정상적으로 적용 되었습니다!마치는 글이렇게 해서 https certificate 생성 부터 Node.js에 적용하는 방법까지 알아보았습니다.certificate을 생성하는 과정은 다소 복잡해 보일 수 있으나 서버에 적용시키는 방법은 생각보다 많이 간단합니다.임의로 생성한 certificate은 안전하지 않으며 절대 실제 production에서는 사용하지 말길 바랍니다.질문이나 피드백이 있다면 언제든지 알려주세요 !Resourceshttps://www.freecodecamp.org/news/how-to-get-https-working-on-your-local-development-environment-in-5-minutes-7af615770eechttps://support.comodo.com/index.php?/Knowledgebase/Article/View/364/17/what-is-a-passphrase-and-how-can-i-change-the-passphrase-on-my-private-key-filehttps://loopback.io/doc/en/lb2/Preparing-for-deployment.html#create-the-https-serverhttps://support.comodo.com/index.php?/Knowledgebase/Article/View/364/17/what-is-a-passphrase-and-how-can-i-change-the-passphrase-on-my-private-key-filehttps://stackoverflow.com/questions/47957538/preparing-loopback-to-use-ssl document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Server/HTTPS/5%EB%B6%84%EC%95%88%EC%97%90-node-js-%EB%A1%9C%EC%BB%AC%ED%98%B8%EC%8A%A4%ED%8A%B8%EC%97%90-https-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"var, let or const 무엇을 써야 할까 ?","text":"모든 예제 코드는 Github에서 확인 가능합니다.좋은 개발자란 무엇이라고 생각하시나요? 정답은 없겠지만 굳이 고르자면 코드를 간결하고 누가 봐도 작성자의 의도를 파악하기 쉽게 작성하는 개발자가 좋은 개발자라고 생각합니다.개발을 하다보면 종종 잠깐 쓰이다 말 변수인데 새로 선언하기도 귀찮고 특히나 이름 짓기가 너무 어려워서 그냥 하나의 변수를 다용도로 사용하고 싶어 지는 유혹(?)이 올 때가 있습니다. 하지만 이런 식의 변수 사용은 코드 작성자의 의도를 파악하기 어려울 뿐만 아니라 유지 보수에도 많은 시간과 비용이 들게 됩니다.따라서 이런 상황을 피하기 위해 자바스크립트 ES6에서 부터 제공되는 const 사용을 지향해야 합니다.constconst 변수의 특징은 처음 선언과 동시에 할당이 되면 재 할당이 불가능합니다.12345const number = 1;number = 2;Output:&gt;TypeError: Assignment to constant variable.const를 기능적으로 바라보았을 땐 단순히 변수의 재할당이 불가능하다 이지만 const를 사용한다는 뜻은 하나의 변수는 하나의 기능만 한다는 뜻을 내포하고 있습니다.다른 개발자가 const로 선언한 변수와 변수명을 보면 해당 변수는 하나의 목적을 위해 만들어졌다는 것이 파악되기 때문에 협업과 유지 보수에 있어서 많은 이점을 가져올 수 있습니다.const 예외한번 할당한 const의 경우 값의 수정이 불가능 하지만 예외는 존재합니다(변경이 안된다면서 이건 또 뭔 소리야 ?)12345678910111213const person = { name: 'Daniel', age: 28,};person.name = 'Andrew';const people = []people.push(person)console.log(person, people)Output:{ name: 'Andrew', age: 28 } [ { name: 'Andrew', age: 28 } ]integer, string 과 같은 JS의 기본 타입을 할당한 경우 변경이 불가능하지만 call by reference 를 사용하는 object나 array 같은 경우는 자유롭게 값을 수정할 수 있습니다.변수가 선언되고 나면 object나 array의 경우 변수는 해당 값의 메모리 주소를 가지고 있기 때문에 실제로 object내 값의 변화에 대해서는 관여하지 않게 됩니다.많은 분들이 const가 constant 또는 immutable이라고 생각하지만 위와 같은 성질 때문에 완전한 immutable이라고 말할 수는 없습니다.const 를 immutable로 사용하기ES5부터 지원되는 Object.freeze()를 이용하면 const object를 immutable변수 할당이 가능합니다.123const foo = Object.freeze({ 'bar': 27 });foo.bar = 42; // TypeError exceptionconsole.log(foo.bar);또는, immutable.js 와 같은 라이브러리를 통해 해결 가능합니다.그렇다면 var과 let의 차이는?항상 const 변수만 사용하면 좋겠지만, const를 사용할 수 없는 경우가 종종 오기도 합니다.for문 안에서 써야 하는 경우나, 복잡한 수학 공식을 계산하는 경우 등 변수 값이 계속해서 바뀌어야 하는 경우는 let을 사용하면 됩니다.var 과 let 둘 다 한번 선언하고 여러번 할당이 가능한 변수지만 둘의 가장 큰 차이점은 var은 function scoped 변수이고, let은 block scoped인 변수라는 점 입니다.예제112345678Input:console.log(x);var x=5;console.log(x);Output:undefined5예제1 var의 경우 변수가 선언이 되지 않았지만 호출이 된다면 현재 scope에서 해당 변수명이 존재하는지 찾고 없다면 다시 상위에서, 또 없다면 그 상위에서 찾으며 scope를 한 단계씩 올라가며 찾게 됩니다.예제21234567Input:console.log(x);let x=5;console.log(x);Output:ReferenceError: x is not defined하지만 예제2 let의 경우 선언과 할당이 이루어진 후에 해당 블록 내에서만 사용이 가능합니다.123456789101112for(var i=0; i&lt;10; i++){ console.log(i); // Output: 0, 1, 2, ... 9}console.log(i); // Output: 10const i = 1; // SyntaxError: Identifier 'i' has already been declaredfor(let j=0; j&lt;10; j++){ console.log(j); // Output: 0, 1, 2, ... 9}console.log(j); // ReferenceError: j is not definedconst j = 1; // 정상적으로 변수선언 가능var과 let 비교의 또다른 예제 입니다.첫번째 for문에서 선언된 var i 는 for문 밖에서도 사용이 가능하며 이후 i 를 선언한 경우 이미 선언된 변수라는 에러 메시지를 출력합니다.두번째 for문에서 선언된 let의 경우 for문 안에서는 정상 동작하지만 for문을 벗어난 시점 부터 존재하지 않는 변수로 처리됩니다.let을 사용한다는 뜻은 해당 변수의 값이 변경 될 수 있지만, 변수가 선언된 블록 내에서만 사용 한다는 뜻을 내포하고 있습니다. 따라서 const를 사용할 수 없는 상황이라면 let을 사용하는 것이 좋습니다.끝으로불가피한 상황이 아닌 이상 항상 const를 사용하는 것이 좋습니다. 추후에 다루어 볼 내용이지만, 함수형 프로그래밍 (Functional Programming) 형태로 코드를 작성하게 되는 경우 변수를 재할당해야 하는 대부분의 상황을 해결 할 수 있습니다. :)Resourceshttps://medium.com/javascript-scene/javascript-es6-var-let-or-const-ba58b8dcde75https://github.com/goldbergyoni/nodebestpractices#-37-prefer-const-over-let-ditch-the-varhttps://www.geeksforgeeks.org/difference-between-var-and-let-in-javascript/https://mathiasbynens.be/notes/es6-const document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Javascript/General/var-let-or-const-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%8D%A8%EC%95%BC-%ED%95%A0%EA%B9%8C/"},{"title":"철수와 영희를 통해 알아보는 HTTPS 기본 개념","text":"들어가는 글,개발자라면 누구나 HTTPS에 대해서 들어 보았을 것입니다. 굳이 개발자가 아니더라도 최근에 정부에서 유해사이트를 전면 차단 하면서 HTTPS를 통해 우회(?)접속까지 막혀 버려 많은 이슈가 되었습니다. ( 실제로 많은 청년들이 길거리에서 시위를 했다는…ㅋㅋㅋ )HTTPS에 대한 기본 개념들을 검색해 보면 아래와 같은 사진들이 자주 등장합니다.이미지 출처네트워크에 대한 지식이 어느정도 있으신 분이라면 금방 이해 하시겠지만.. 여전히 복잡해 보이는 건 마찬가지 입니다.이번 포스트에서는 HTTPS 통신 방법을 철수와 영희를 예시로 들어 알아보려고 합니다.HTTPS란 Hypertext Transfer Protocol Secure (기존 HTTP에 Secure를 뜻하는 S를 더함)의 약자로 정보를 주고받을때 암호화를 하여 통신하는 방식을 의미합니다.암호화 통신을 통해 중간에 해커로 부터 데이터를 탈취 당하더라도 내용을 알아볼 수 없다라는 이점이 있으며, 방문하는 블로그 등의 사이트에서 브라우저 정보를 수집 할 때도 HTTP통신에 비해 한정적인 데이터가 수집된다는 이점도 존재합니다.기존의 통신 방법기존 HTTP통신 방법에서는 암호화가 전혀 이루어지지 않았습니다.예를 들어, 철수와 영희가 연애편지를 주고받는다고 생각해 보겠습니다. 둘은 아날로스 방식으로 편지를 서로 주고받고 있는데 이 사이를 질투한 민수가 중간에서 편지를 훔쳐(탈취하여) 내용을 보고 수정을 한다면 어떻게 될까요 ?암호화나 보안 관련 작업이 전혀 이루어지지 않은 편지는 중간에 무슨일이 일어나도 철수와 영희는 이 사실조차 인지하지 못 할 것입니다. 그저 마음이 변해버린 영희를 그리워하는 철수만 남을 뿐.. (ㅠㅠ)이 문제를 해결하기 위해 등장한 방법이 대칭키 암호화(symmetric key cryptography) 방식입니다.대칭키 암호화대칭키 암호화 방식은 암호화 하는 키와 복호화 하는 키가 같아서 대칭키라는 이름이 붙었습니다.편지를 주고받던 철수와 영희는 그들만의 비밀편지를 누군가가 엿보는 것이 우려되기 시작하였습니다. 따라서 둘은 서로가 쓰는 편지를 남들이 알아볼 수 없도록 모든 글자를 3자리 앞에 존재하는 글자로 치환한 다음 편지를 보내고 (암호화) 받았을 때 역시 모든 글자를 3자리 뒤에 존재하는 글자로 치환(복호화)하여 보기로 하였습니다.예를 들어 D → A, E → B, F → C 이런 식으로 글자를 3자리씩 앞으로 옮긴다면 “secret message”는 “pbzobq jbppxdb”가 될 것입니다.이렇게 암호화키와 복호화키가 같은 경우를 대칭키 암호화라고 부릅니다.하지만 위의 방법에는 치명적인 단점이 있습니다. 우선 철수와 영희가 직접적으로 만나지 않는 이상 암호화/복호화 방법을 편지를 통해 주고 받아야 하는데 이 과정에서 이미 민수에게 내용이 노출될 수 있다는 점과 평소 암호학을 공부하던 민수는 이렇게 간단한 암호화 기법은 손쉽게 풀어 버릴 수 도 있기 때문입니다.따라서 이를 우려한 철수와 영희는 비대칭 암호화(asymmetric key cryptography) 방식을 통하여 서로 비밀 편지를 주고 받도록 합니다..비대칭키 암호화철수와 영희는 다음와 같은 방법을 생각해 냅니다.철수는 영희에게 아무것도 적혀있지 않는 편지를 먼저 보낸다.영희는 잠겨있지 않는 박스에 박스 열쇠를 넣어 다시 철수에게 보낸다.철수는 박스에 편지를 담은 후 박스를 잠그고 해당 박스를 영희에게 보낸다.영희는 박스를 열어 편지를 확인한다.위의 방법은 암호화와 복호화의 키가 서로 같지 않기 때문에 비대칭키 암호화라고 불립니다. 왜냐하면 박스를 중간에 가로채어 닫는 데는 성공 하여도 닫혀 있는 박스를 열수는 없기 때문입니다.여기서 박스는 공개키(public key)가 되는 것이고, 박스를 여는 열쇠는 비공개키(private key)가 됩니다.여기서의 또다른 문제점이미 눈치채신 분도 계시겠지만 여기서 철수가 박스를 받았을 때 어떻게 영희가 보낸 박스 인지 믿을 수 있을까요 ?영희는 따라서 자신이 보낸 박스가 맞다는 서명을 함께 동봉하여 철수에게 보내기로 하였습니다.하지만 영희의 서명을 한번도 본적이 없는 철수는 여전히 민수가 보낸 박스 인지 의심할 수 밖에 없는 상황입니다.여기서 철수와 영희는 모두가 다 알고, 믿을만한 사람인 선생님께 박스에 서명을 하도록 부탁 하기로 합니다.선생님은 박스를 받았을 때 영희가 준 것을 확인한 후에야 박스에 서명을 해주기로 약속합니다. 여기서 선생님의 역할을 Certification Authority (CA)라고 부릅니다.선생님의 서명을 알고 있던 철수는 영희가 보낸 박스가 맞다는 사실에 안도하며 둘만의 안전한(?) 비밀편지를 주고 받을수 있게 되었습니다.이미지 출처끝으로,,HTTPS의 통신 방법을 철수와 영희의 예시로 들어 보았습니다. 실제로 HTTPS가 적용되어 있는 웹페이지에 접속한다면 선생님의 역할 이였던 CA의 서명과 정보가 함께 동봉되어 브라우저로 전달이 됩니다.HTTP에 비해서 절차가 많고 암호화가 되는 등 웹페이지가 상대적으로 느려지는 단점이 존재합니다. 따라서 실제로는 비대칭키 암호화는 암호화키를 주고 받을때 만 사용됩니다.긴 글 읽어 주셔서 감사합니다.잘못된 내용이 있거나 수정해야 할 내용이 있다면 언제든지 알려주세요.!Resourceshttps://medium.com/free-code-camp/https-explained-with-carrier-pigeons-7029d2193351https://www.thesslstore.com/blog/what-happens-when-your-ssl-certificate-expires/https://love2dev.com/blog/how-https-works/ document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Server/HTTPS/%EC%B2%A0%EC%88%98%EC%99%80-%EC%98%81%ED%9D%AC%EB%A5%BC-%ED%86%B5%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-https-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90/"},{"title":"async라이브러리에 대해 알아보자","text":"모든 예제 코드는 Github에서 확인 가능합니다.자바스크립트에서 기본적으로 제공하는 async/await을 통해 대부분의 비동기 작업에 대해 간단하게 구현이 가능합니다. 하지만 연속적으로 병렬 작업을 처리해야 하거나 하나의 함수에서 반환된 값을 다른 함수에 적용하는 등 다양한 플로우에 대해 개발자가 매번 구현해야 하는 번거로움이 존재합니다.async 라이브러리는 비동기적인 병렬 처리, chaining, 분기문, 반복 처리 등에 대해 직관적이며 간단한 기능들을 제공합니다.async 설치패키지 매니저를 통해서 간단하게 설치할 수 있습니다.1npm install asyncasync의 유용한 기능들async의 몇몇 메소드를 제외한 대부분은 테스크가 끝났음을 알려주는 callback 함수를 제공합니다. callback 함수의 첫 번째 인자는 항상 error 값이 들어가야 하며 두번째 인자는 전달하려는 결과값이 들어갑니다. error가 없으면 null로 입력해도 되고, 전달하려는 결과값이 없는 경우 그냥 callback() 을 호출하는 식으로 처리할 수 있습니다.parallel개인적으로 가장 많이 사용하는 병렬처리 메소드 입니다. 아래와 같이 배열에 처리하고 싶은 비동기 작업들을 callback 을 인자로 받는 함수 형태로 선언합니다. 100ms 이후에 전달받은 값에 10을 더하는 함수를 병렬로 실행하는 코드입니다.123function add10(a, callback) { //100ms 이후 10을 더한값을 callback에 입력 setTimeout(() =&gt; callback(null, a + 10), 100);}1234567891011const tasks = [ // 병렬처리할 함수들 정의 callback =&gt; add10(10, callback), callback =&gt; add10(10, callback), callback =&gt; add10(10, callback)];async.parallel(tasks, (err, results) =&gt; { // 병렬 실행 후 err와 results를 반환 console.log(err, results);});Output:null [ 20, 20, 20 ] // err가 없으므로 null이 반환됨동작 방식은 다음과 같습니다async.parallel이 실행되면 tasks 배열에 들어있는 작업들이 병렬로 실행되게 됩니다. 각각의 작업은 함수로 선언되어 있으며 callback을 인자로 받아들입니다. add10에서 작업이 완료되면 결과값을 callback에 넣어 호출함으로써 작업이 끝났음을 async에 알립니다.각 task를 처리하는데 시간이 조금씩 다르게 걸리며 마지막 task까지 callback을 호출하게 된다면 결과값을 async.parallel의 2번째 인자로 전달합니다.작업 실행 도중 문제가 없었다면 error는 null로 반환되며 results에는 tasks 내에 정의된 작업의 순서에 맞게 결과값을 배열로 전달합니다.waterfall이번에 알아볼 메소드는 waterfall입니다. 이름에서 이미 짐작하셨겠지만 정의된 작업들의 결과가 다음 작업으로 전달되면서 순차적으로 처리되는 방식입니다.아래의 예시는 순차적으로 add10을 실행하여 10을 누적하여 더하는 코드입니다.1234567891011const tasks = [ (callback) =&gt; add10(10, callback), (res, callback) =&gt; add10(res, callback), // res는 tasks의 0번째 배열에서 넘겨받은 결과값 (res, callback) =&gt; add10(res, callback) // res는 tasks의 1번째 배열에서 넘겨받은 결과값];async.waterfall(tasks, (err, results) =&gt; { console.log(err, results); // 최종 결과값 출력});Output:null 40tasks에 정의된 작업들을 순차적으로 처리해 나갑니다. 0번째 배열은 이전 작업이 없기 때문에 인자를 callback만 받아들이며 1번째 배열부터 이전 배열에서 처리한 데이터를 넘겨받습니다.waterfall은 회원가입 시 순차적으로 아이디 비밀번호를 확인하고 결과값을 가지고 회원정보를 확인 후 반환하는 등 대부분의 순차적인 작업에 적합한 메소드입니다.each배열에 정의된 작업들을 반복적으로 처리해야 하는 경우 async.each를 사용하시면 됩니다.12345678910111213141516171819202122232425const tasks = [ // 반복적으로 처리해야하는 함수나 값 선언 add10, add10, add10, add10, add10,];// async.each의 두번째 인자는 tasks에서 하나씩 가져온 각각의 task와 callbackasync.each(tasks, (eachTask, callback) =&gt; { eachTask(10, (err, result) =&gt; { console.log(result); callback(err); // 작업이 끝났음을 알림 })}, (err) =&gt; { // 위의 반복문이 모두 실행되면 마지막으로 err를 인자로 받는 함수 실행 console.log(err)});Output:2020202020null반복적으로 비동기적인 업무를 처리할 때 아주 좋은 함수입니다.만약 1만 개의 유저 데이터가 배열에 들어가 있고 각각의 유저에 대해 유저 프로필을 호출한 다음 특정 값을 입력해야 하는 등의 작업을 처리할 때 유용합니다.여기서 주의할 점은 each에 들어가는 작업은 순차적이 아닌 병렬적으로 실행된다는 것입니다. 따라서 실행 순서를 보장하지 않기 때문에 예상한 결과가 나오지 않는 경우가 많습니다.반복문의 실행 순서가 중요한 경우 async.eachSeries를 사용하시면 됩니다. 하나의 작업이 다 끝나고 다음 작업을 순차적으로 실행하기 때문에 처리 속도가 상당히 느려지는 단점이 존재합니다.그 이외에 반복적으로 처리한 값을 하나의 결과로 전달받아야 하는 경우 async 함수 바깥쪽에 const agg = [] 와 같이 정의해서 결과값을 push 하는 것이 아닌 async.map 을 사용하면 간단하게 해결할 수 있습니다.whilst마지막으로 알아볼 메소드는 분기문인 whilst 입니다.12345678910111213let count = 0;async.whilst( (callback) =&gt; { callback(null, count &lt; 5) }, (callback) =&gt; { count++; setTimeout(function() { callback(null, count); }, 100); }, (err, n) =&gt; { console.log(err, n); });첫 번째 인자로 조건문을 받아들이며 두 번째 인자는 조건문이 true일 동안 실행되게 됩니다. 조건문이 false가될 경우 세 번째 인자로 받아들인 함수를 실행하게 되며 결과값도 함께 전달됩니다.끝으로이렇게 해서 기본적인 async 라이브러리의 사용 방법에 대해 알아보았습니다. 개인적으로는 Promise 나 async/await 보다 상당히 편해서 자주 사용하는 라이브러리입니다. 위에서 언급한 메소드만 잘 조합해도 대부분의 작업들은 문제없이 구현 가능하며 이외에도 다양한 메소드들을 제공하고 있으니 async 공식 documentation을 꼭 확인하시길 바랍니다.궁금한 점이나 피드백이 있다면 언제든지 알려주세요 ! document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Javascript/General/async%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90/"},{"title":"Wireshark로 HTTPS 암호화 검증하기","text":"최근 HTTPS 관련 작업을 하다가 문득 정말로 암호화가 되기는 하는 걸까? 라는 의문이 들기 시작하였습니다.(사실 HTTPS를 적용하는 방법이 너무 간단해서 더 의심이 됐다는..)이론상으로는 비대칭키를 이용한 암호화 통신을 통해 중간에서 정보가 탈취 되더라도 알아볼 수 없다 라고는 하는데 여전히 의구심이 들어 직접 확인해 보기로 했습니다.WiresharkWireshark(와이어샤크)란 오픈 소스 패킷 분석 프로그램입니다. 현재 내 컴퓨터에서 주고받는 네트워크 패킷을 캡쳐 해서 세부 내용들을 확인해 볼 수 있으며 직접적인 연결 뿐만 아니라 브로드캐스트, 멀티캐스트 등의 내용도 확인할 수 있습니다.실제로 컴퓨터에 연결된 케이블에서 무슨 일이 일어나는지 알아낼 수 있는 아주아주아주 중요하고 좋은 툴입니다.과거 보안 관련 일을 할 때 DDOS바이러스에 걸린 컴퓨터가 특정 IP로 heartbeat(서버에 클라이언트가 살아있다는 정보)를 보내는 패킷을 캡쳐 해서 무슨 정보를 주고받고 있으며, 해당 컴퓨터 내 무슨 프로세스가 바이러스로 동작 하는지 파악할 수 있었습니다.이제 본론으로 들어가자면,,HTTP 방식 GET REQUEST먼저 HTTP로 통신하는 API서버에 GET REQUEST를 해보겠습니다. 통신 순서는 단순하게 클라이언트에서 GET REQUEST를 보내면 서버에서 해당 값을 RESPONSE해주는 1차원 적인 방식입니다.테스트용으로 만든 API서버에 HTTP GET REQUEST를 해보았습니다.결과의 첫번째 줄은 클라이언트 → 서버 REQUEST, 두번째 줄은 서버 → 클라이언트 RESPONSE입니다클라이언트 → 서버 GET REQUEST 패킷을 열어 보면 다음과 같이 어느 URL로 무슨 정보를 REQUEST했는지 볼 수 있습니다. 그 이외에도 네트워크 관련 많은 정보들을 보여주는데 이는 추후 Wireshark에 관련해서 별도로 다뤄 보도록 하겠습니다.간혹 가다가 HTTP에서 header나 post를 이용하여 accessToken과 같은 중요한 정보를 숨기면 되지 않느냐는 질문을 하시는 분들이 계시는데 이는 URL에서만 보이지 않을 뿐 보안 적인 기능을 전혀 하지 않는 방법입니다.실제로 테스트용 API서버는 accessToken을 header로만 주고받도록 되어 있는데 위와 같이 모든 정보들이 그대로 보여 지게 됩니다.다음은 서버 → 클라이언트 RESPONSE내용 입니다. JSON형식으로 반환되는 데이터들이 key-value 별로 아주 예쁘게(?) 정리되어 있습니다.ㅎㅎHTTPS 통신 방식HTTPS의 통신 방식은 다음과 같습니다.이미지 출처서버와 클라이언트에서 서로 인증서와 키를 주고 받은 다음 암호화된 데이터로 통신을 하는 방식이며, HTTPS 통신에 대한 기본 개념에 대해 잘 모르시는 분들은 이전포스트 를 확인해 주세요.HTTPS 방식 GET REQUESTHTTPS로 동일한 API에 GET REQUEST를 해보았습니다.가장 먼저 보이는 차이점은 Protocol이 이전에는 HTTP였다면 지금은 TCP와 TLS로만 통신을 하게 됩니다.위에서 부터 순서대로 서버와 클라이언트가 인증서와 키를 주고받은 다음 암호화 통신에 필요한 기본적인 정보들을 주고 받게 됩니다. HandShake 까지 완료가 되면 그 뒤로 REQUEST 와 RESPONSE가 진행됩니다.Application Data 패킷을 열어 보면 Port 역시 HTTP가 사용하는 80포트가 아닌 443 포트를 사용하는 것을 볼 수 있으며, 모든 내용은 예상과 같이 암호화가 되어 보여 집니다.마치는 글이렇게 실제로 HTTPS가 암호화되어 통신을 하는지 확인해 보았습니다.예전 같았으면 당연히 내부적으로 잘 동작 하겠지 라고 생각했겠지만 최근들어 당연한 것도 한번 더 확인해 보는 습관이 생긴 것 같습니다. 조금 귀찮긴 하지만 자세히 확인해보면 몰랐던 내용도 많이 알 수 있어서 좋은 경험이 된 것 같습니다.질문이나 피드백이 있다면 언제든지 연락 주세요 .!Resourceshttps://www.wireshark.org/docs/wsug_html_chunked/ChapterIntroduction.html#ChIntroWhatIs document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Server/HTTPS/wireshark%EB%A1%9C-https-%EC%95%94%ED%98%B8%ED%99%94-%EA%B2%80%EC%A6%9D%ED%95%98%EA%B8%B0/"},{"title":"자바스크립트 비동기통신 Callback, Promise, Async/Await 이해하기","text":"모든 예제 코드는 Github에서 확인 가능합니다.자바스크립트를 공부하다 보면 항상 Promise와 Async/Await 관련 글들을 많이 보게 되는데요.자주 쓰이고 중요한 내용들이지만 많은 저를 포함해 많은 분들이 햇갈려 하거나 아직 정확히 개념이 안 잡혀 있는 경우가 많습니다. 이번 포스트에서는 기본적인 비동기 통신 개념부터, Callbacks, Promises, Async/Await에 대해 알아보겠습니다.자바스크립트는 다른 언어들과는 다르게 싱글 스레드(Single Threaded Language)를 사용하는 언어입니다. 다시 말해서 자바스크립트는 한번에 한 개의 일만 순차적으로 처리할 수 있습니다.병렬 처리를 할 수 없는 자바스크립트는 기존 병렬 처리가 필요한 작업들을 “asynchronous non-blocking I/O model“ 이라는 방식을 통해 해결하고 있습니다. 프로그램이 실행되는 동안 서버로 부터 정보를 불러오거나, 데이터베이스에서 데이터를 가져와야 하는 경우 실행 되던 프로그램이 잠시 멈추고 I/O operation들이 해당 작업을 처리한 후 다시 작업을 계속해 나가는 방식으로 처리됩니다.언어 자체는 병렬처리가 불가능 하지만 자바스크립트를 해석하고 실행하는 엔진에서는 I/O관련 작업들을 내부적으로 병렬 처리를 하게 됩니다.Callbacks자바스크립트에서는 함수가 받아들이는 값을 int, string 형 뿐만 아니라 함수로도 받아들일 수 있습니다. 인자로 받아들인 함수를 다시 호출하는 기능을 callback이라고 부릅니다.Callback 예제1234567function add5(a, callback) { setTimeout(() =&gt; callback(a + 5), 100)// 100ms가 지난 후 함수로 입력받은 callback에 a + 10값을 다시 입력하여 callback함수 호출}add5(10, function (res) { // add5가 입력받는 callback함수 정의 부분 console.log(res)});add5를 호출하는 부분을 보시면 첫 번째 인자로 숫자 5, 두 번째로는 함수를 생성하여 전달하는 것을 볼 수 있습니다. add5 함수 내부에서는 입력 받은 함수 callback에 a + 5를 하여 다시 호출하게 됩니다.Callback HellCallback이란 처음엔 조금 어렵지만 한번 이해하게 되면 굉장히 편한 기능입니다. 하지만 callback은 연속적으로 사용하게 되면 유지보수가 힘들어 진다는 치명적인 단점이 존재합니다이번에는 위의 예제에서 만든 add5를 연속적으로 호출하여 10에 5 + 5 + 5 + 5 를 하는 코드입니다.123456789add5(10, res =&gt; { add5(res, res =&gt; { add5(res, res =&gt; { add5(res, res =&gt; { console.log(res) }) }) })})단순히 더하기만 하는 코드지만 함수를 재귀적으로 여러번 호출하기 때문에 다소 복잡해 보입니다.실제로 로그인 기능을 구현할 때 로그인 정보를 받아들여 비밀번호를 확인하고, 옳다면 유저 정보를 가져오고 틀리다면 에러 메시지를 출력하는 등 if-else문이 callback 중간 중간에 들어가야 하는 경우가 자주 있습니다.따라서 callback을 4번5번 연속적으로 호출하게 될 경우 callback hell 을 맛보실 수 있게 됩니다. 하하PromisesPromise란 기본적으로 callback이 하는 일과 같습니다. 다만 차이점이라면 Promise는 작업이 끝난 후 실행할 함수를 제공하는 것이 아니라 Promise 자체 메소드인 .then()을 호출하게 됩니다.Promise 특징123456789function add10(a) { return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(a + 10), 100));} //Promise사용 시 작업이 끝났음을 알려주는 resolve를 인자로 받아들임.add10(10) .then(add10) .then(add10) .then(add10) .then((res) =&gt; console.log(res))Promise는 then()과 같은 메소드를 연속적으로 사용이 가능한 이점을 가지고 있습니다. 따라서 callback을 사용했을 때와는 다르게 코드를 작성하고 이해하기가 한결 쉬워졌습니다.!이처럼 메소드를 연속적으로 사용하는 chaining이 가능한 이유는 add10 함수가 결과값을 Promise로 리턴하기 때문입니다. 실제로 add10의 결과값을 출력해보면 값이 다음과 같이 출력되는 것을 볼 수 있습니다.12console.log(add10(10));&gt;&gt; Promise { &lt;pending&gt; }Promise에서의 예외 처리12345add10(10) .then((res) =&gt; { throw 'test error'; }) .catch((err) =&gt; console.log(err));Promise에서는 작업이 실패하였을 경우 자동으로 .catch() 메소드가 호출되게 됩니다. 따라서 callback과 같이 함수 호출 중간에 if-else를 사용하는 것이 아닌 .catch()로 한번에 해결할 수 있는 장점이 있습니다.12345678try { add10(10) .then((res) =&gt; { throw 'test error'; })} catch(err) { console.log(err)}기존 try-catch를 이용해서도 예외 처리가 가능하지만 자바스크립트에서는 Promise의 catch를 사용 하라는 warning message를 출력하게 됩니다.Async/AwaitNodeJs 버전 7.6부터 구현된 기능이며 Async/Await를 사용하면 Promise에 비해 보다 쉽게 비동기적인 상황을 표현할 수 있습니다.123456async function f1() { const a = await add10(10); const b = await add10(a); console.log(a, b)}f1();Async와 Await을 사용하려면 우선 사용할 함수 앞에 async라는 키워드를 붙여 사용해야 하며 선언된 async 함수 안에서만 await 키워드를 사용할 수 있습니다.await은 함수의 작업이 끝나고 결과값을 반환할 때까지 대기하게 되며 결과 값이 리턴된다면 다음 작업으로 넘어가게 됩니다.Async/Await에서의 예외 처리123456async function f2() { const a = await add10(10).then(res =&gt; res); const b = await add10(a).catch(err =&gt; err); console.log(a, b)}f2();위의 예제에서는 add10이 Promise를 리턴하므로 Promise가 지원하는 메소드들을 바로 사용할 수 있습니다. 따라서 .catch()를 이용하여 예외 처리가 가능합니다.12345678910async function f3() { try { const a = await add10(10) const b = await add10(a) console.log(a, b) } catch(err) { console.log(err) }}f3();또는 기존과 같은 방식의 try-catch를 이용한 예외 처리를 할 수 있습니다.끝으로이렇게 callback, Promise 그리고 async/await에 대해 알아보았습니다.async와 await이 코드 작성 시 조금 더 동기적으로 보일 수 있지만 callback이나 promise 형태의 API를 사용하게 된다면 내부적으로는 Promise와 동일하게 I/O Operator 들에 의해 병렬적으로 동작하게 되며 비동기 테스크들이 끝나고 결과값을 반환할 때까지 그 이후의 코드들을 실행하지 않고 기다리게 됩니다.개인적으로는 async/await 역시 Promise에 비해 코드 작성이 편하다고 생각이 들지만 예외 처리나 테스크들을 작성함에 있어서 약간 불편하다는 생각이 듭니다. 따라서 저는 async라는 외부 라이브러리를 자주 사용합니다.async에 관한 내용은 다음 포스트에서 다루어 보도록 하겠습니다.긴 글 읽어주셔서 감사하며 피드백이나 수정사항이 있다면 언제든지 연락 주세요.Resourceshttps://dev.to/farahanjum/callbacks-promises-in-javascript-2b6https://medium.com/codebuddies/getting-to-know-asynchronous-javascript-callbacks-promises-and-async-await-17e0673281ee document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Javascript/General/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%B9%84%EB%8F%99%EA%B8%B0%ED%86%B5%EC%8B%A0-callback-promise-async-await-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/"}],"tags":[{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"Async","slug":"Async","link":"/tags/Async/"},{"name":"Security","slug":"Security","link":"/tags/Security/"},{"name":"Wireshark","slug":"Wireshark","link":"/tags/Wireshark/"}],"categories":[{"name":"Server","slug":"Server","link":"/categories/Server/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"HTTPS","slug":"Server/HTTPS","link":"/categories/Server/HTTPS/"},{"name":"General","slug":"Javascript/General","link":"/categories/Javascript/General/"}]}