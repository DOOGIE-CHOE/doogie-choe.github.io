{"pages":[{"title":"","text":"안녕하세요, 블로그를 운영하고 있는 최용득 입니다.삶을 살아가다 보면 좋아서 시작한 일들이 어느 순간부터 재미없고 귀찮아지는 순간이 있습니다.저에게 있어서 개발자의 삶 역시 그런 순간들을 종종 마주하게 되는데요, 그런 순간들이 싫지만 동시에 제 삶을 돌아볼 수 있는 계기가 되는 것 같습니다.지금까지도 그랬지만 앞으로도 계속해서 개발 일을 좋아하고, 때로는 슬럼프도 마주하면서 자신을 되돌아보는 그런 삶을 살려고 노력하고 있습니다. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"Wireshark로 HTTPS 암호화 검증하기","text":"최근 HTTPS 관련 작업을 하다가 문득 정말로 암호화가 되기는 하는 걸까? 라는 의문이 들기 시작하였습니다.(사실 HTTPS를 적용하는 방법이 너무 간단해서 더 의심이 됐다는..)이론상으로는 비대칭키를 이용한 암호화 통신을 통해 중간에서 정보가 탈취 되더라도 알아볼 수 없다 라고는 하는데 여전히 의구심이 들어 직접 확인해 보기로 했습니다.WiresharkWireshark(와이어샤크)란 오픈 소스 패킷 분석 프로그램입니다. 현재 내 컴퓨터에서 주고받는 네트워크 패킷을 캡쳐 해서 세부 내용들을 확인해 볼 수 있으며 직접적인 연결 뿐만 아니라 브로드캐스트, 멀티캐스트 등의 내용도 확인할 수 있습니다.실제로 컴퓨터에 연결된 케이블에서 무슨 일이 일어나는지 알아낼 수 있는 아주아주아주 중요하고 좋은 툴입니다.과거 보안 관련 일을 할 때 DDOS바이러스에 걸린 컴퓨터가 특정 IP로 heartbeat(서버에 클라이언트가 살아있다는 정보)를 보내는 패킷을 캡쳐 해서 무슨 정보를 주고받고 있으며, 해당 컴퓨터 내 무슨 프로세스가 바이러스로 동작 하는지 파악할 수 있었습니다.이제 본론으로 들어가자면,,HTTP 방식 GET REQUEST먼저 HTTP로 통신하는 API서버에 GET REQUEST를 해보겠습니다. 통신 순서는 단순하게 클라이언트에서 GET REQUEST를 보내면 서버에서 해당 값을 RESPONSE해주는 1차원 적인 방식입니다.테스트용으로 만든 API서버에 HTTP GET REQUEST를 해보았습니다.결과의 첫번째 줄은 클라이언트 → 서버 REQUEST, 두번째 줄은 서버 → 클라이언트 RESPONSE입니다클라이언트 → 서버 GET REQUEST 패킷을 열어 보면 다음과 같이 어느 URL로 무슨 정보를 REQUEST했는지 볼 수 있습니다. 그 이외에도 네트워크 관련 많은 정보들을 보여주는데 이는 추후 Wireshark에 관련해서 별도로 다뤄 보도록 하겠습니다.간혹 가다가 HTTP에서 header나 post를 이용하여 accessToken과 같은 중요한 정보를 숨기면 되지 않느냐는 질문을 하시는 분들이 계시는데 이는 URL에서만 보이지 않을 뿐 보안 적인 기능을 전혀 하지 않는 방법입니다.실제로 테스트용 API서버는 accessToken을 header로만 주고받도록 되어 있는데 위와 같이 모든 정보들이 그대로 보여 지게 됩니다.다음은 서버 → 클라이언트 RESPONSE내용 입니다. JSON형식으로 반환되는 데이터들이 key-value 별로 아주 예쁘게(?) 정리되어 있습니다.ㅎㅎHTTPS 통신 방식HTTPS의 통신 방식은 다음과 같습니다.이미지 출처서버와 클라이언트에서 서로 인증서와 키를 주고 받은 다음 암호화된 데이터로 통신을 하는 방식이며, HTTPS 통신에 대한 기본 개념에 대해 잘 모르시는 분들은 이전포스트 를 확인해 주세요.HTTPS 방식 GET REQUESTHTTPS로 동일한 API에 GET REQUEST를 해보았습니다.가장 먼저 보이는 차이점은 Protocol이 이전에는 HTTP였다면 지금은 TCP와 TLS로만 통신을 하게 됩니다.위에서 부터 순서대로 서버와 클라이언트가 인증서와 키를 주고받은 다음 암호화 통신에 필요한 기본적인 정보들을 주고 받게 됩니다. HandShake 까지 완료가 되면 그 뒤로 REQUEST 와 RESPONSE가 진행됩니다.Application Data 패킷을 열어 보면 Port 역시 HTTP가 사용하는 80포트가 아닌 443 포트를 사용하는 것을 볼 수 있으며, 모든 내용은 예상과 같이 암호화가 되어 보여 집니다.마치는 글이렇게 실제로 HTTPS가 암호화되어 통신을 하는지 확인해 보았습니다.예전 같았으면 당연히 내부적으로 잘 동작 하겠지 라고 생각했겠지만 최근들어 당연한 것도 한번 더 확인해 보는 습관이 생긴 것 같습니다. 조금 귀찮긴 하지만 자세히 확인해보면 몰랐던 내용도 많이 알 수 있어서 좋은 경험이 된 것 같습니다.질문이나 피드백이 있다면 언제든지 연락 주세요 .!Referencehttps://www.wireshark.org/docs/wsug_html_chunked/ChapterIntroduction.html#ChIntroWhatIs document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Server/HTTPS/wireshark%EB%A1%9C-https-%EC%95%94%ED%98%B8%ED%99%94-%EA%B2%80%EC%A6%9D%ED%95%98%EA%B8%B0/"},{"title":"철수와 영희를 통해 알아보는 HTTPS 기본 개념","text":"들어가는 글,개발자라면 누구나 HTTPS에 대해서 들어 보았을 것입니다. 굳이 개발자가 아니더라도 최근에 정부에서 유해사이트를 전면 차단 하면서 HTTPS를 통해 우회(?)접속까지 막혀 버려 많은 이슈가 되었습니다. ( 실제로 많은 청년들이 길거리에서 시위를 했다는…ㅋㅋㅋ )HTTPS에 대한 기본 개념들을 검색해 보면 아래와 같은 사진들이 자주 등장합니다.이미지 출처네트워크에 대한 지식이 어느정도 있으신 분이라면 금방 이해 하시겠지만.. 여전히 복잡해 보이는 건 마찬가지 입니다.이번 포스트에서는 HTTPS 통신 방법을 철수와 영희를 예시로 들어 알아보려고 합니다.HTTPS란 Hypertext Transfer Protocol Secure (기존 HTTP에 Secure를 뜻하는 S를 더함)의 약자로 정보를 주고받을때 암호화를 하여 통신하는 방식을 의미합니다.암호화 통신을 통해 중간에 해커로 부터 데이터를 탈취 당하더라도 내용을 알아볼 수 없다라는 이점이 있으며, 방문하는 블로그 등의 사이트에서 브라우저 정보를 수집 할 때도 HTTP통신에 비해 한정적인 데이터가 수집된다는 이점도 존재합니다.기존의 통신 방법기존 HTTP통신 방법에서는 암호화가 전혀 이루어지지 않았습니다.예를 들어, 철수와 영희가 연애편지를 주고받는다고 생각해 보겠습니다. 둘은 아날로스 방식으로 편지를 서로 주고받고 있는데 이 사이를 질투한 민수가 중간에서 편지를 훔쳐(탈취하여) 내용을 보고 수정을 한다면 어떻게 될까요 ?암호화나 보안 관련 작업이 전혀 이루어지지 않은 편지는 중간에 무슨일이 일어나도 철수와 영희는 이 사실조차 인지하지 못 할 것입니다. 그저 마음이 변해버린 영희를 그리워하는 철수만 남을 뿐.. (ㅠㅠ)이 문제를 해결하기 위해 등장한 방법이 대칭키 암호화(symmetric key cryptography) 방식입니다.대칭키 암호화대칭키 암호화 방식은 암호화 하는 키와 복호화 하는 키가 같아서 대칭키라는 이름이 붙었습니다.편지를 주고받던 철수와 영희는 그들만의 비밀편지를 누군가가 엿보는 것이 우려되기 시작하였습니다. 따라서 둘은 서로가 쓰는 편지를 남들이 알아볼 수 없도록 모든 글자를 3자리 앞에 존재하는 글자로 치환한 다음 편지를 보내고 (암호화) 받았을 때 역시 모든 글자를 3자리 뒤에 존재하는 글자로 치환(복호화)하여 보기로 하였습니다.예를 들어 D → A, E → B, F → C 이런 식으로 글자를 3자리씩 앞으로 옮긴다면 “secret message”는 “pbzobq jbppxdb”가 될 것입니다.이렇게 암호화키와 복호화키가 같은 경우를 대칭키 암호화라고 부릅니다.하지만 위의 방법에는 치명적인 단점이 있습니다. 우선 철수와 영희가 직접적으로 만나지 않는 이상 암호화/복호화 방법을 편지를 통해 주고 받아야 하는데 이 과정에서 이미 민수에게 내용이 노출될 수 있다는 점과 평소 암호학을 공부하던 민수는 이렇게 간단한 암호화 기법은 손쉽게 풀어 버릴 수 도 있기 때문입니다.따라서 이를 우려한 철수와 영희는 비대칭 암호화(asymmetric key cryptography) 방식을 통하여 서로 비밀 편지를 주고 받도록 합니다..비대칭키 암호화철수와 영희는 다음와 같은 방법을 생각해 냅니다.철수는 영희에게 아무것도 적혀있지 않는 편지를 먼저 보낸다.영희는 잠겨있지 않는 박스에 박스 열쇠를 넣어 다시 철수에게 보낸다.철수는 박스에 편지를 담은 후 박스를 잠그고 해당 박스를 영희에게 보낸다.영희는 박스를 열어 편지를 확인한다.위의 방법은 암호화와 복호화의 키가 서로 같지 않기 때문에 비대칭키 암호화라고 불립니다. 왜냐하면 박스를 중간에 가로채어 닫는 데는 성공 하여도 닫혀 있는 박스를 열수는 없기 때문입니다.여기서 박스는 공개키(public key)가 되는 것이고, 박스를 여는 열쇠는 비공개키(private key)가 됩니다.여기서의 또다른 문제점이미 눈치채신 분도 계시겠지만 여기서 철수가 박스를 받았을 때 어떻게 영희가 보낸 박스 인지 믿을 수 있을까요 ?영희는 따라서 자신이 보낸 박스가 맞다는 서명을 함께 동봉하여 철수에게 보내기로 하였습니다.하지만 영희의 서명을 한번도 본적이 없는 철수는 여전히 민수가 보낸 박스 인지 의심할 수 밖에 없는 상황입니다.여기서 철수와 영희는 모두가 다 알고, 믿을만한 사람인 선생님께 박스에 서명을 하도록 부탁 하기로 합니다.선생님은 박스를 받았을 때 영희가 준 것을 확인한 후에야 박스에 서명을 해주기로 약속합니다. 여기서 선생님의 역할을 Certification Authority (CA)라고 부릅니다.선생님의 서명을 알고 있던 철수는 영희가 보낸 박스가 맞다는 사실에 안도하며 둘만의 안전한(?) 비밀편지를 주고 받을수 있게 되었습니다.이미지 출처끝으로,,HTTPS의 통신 방법을 철수와 영희의 예시로 들어 보았습니다. 실제로 HTTPS가 적용되어 있는 웹페이지에 접속한다면 선생님의 역할 이였던 CA의 서명과 정보가 함께 동봉되어 브라우저로 전달이 됩니다.HTTP에 비해서 절차가 많고 암호화가 되는 등 웹페이지가 상대적으로 느려지는 단점이 존재합니다. 따라서 실제로는 비대칭키 암호화는 암호화키를 주고 받을때 만 사용됩니다.긴 글 읽어 주셔서 감사합니다.잘못된 내용이 있거나 수정해야 할 내용이 있다면 언제든지 알려주세요.!Referencehttps://medium.com/free-code-camp/https-explained-with-carrier-pigeons-7029d2193351https://www.thesslstore.com/blog/what-happens-when-your-ssl-certificate-expires/https://love2dev.com/blog/how-https-works/ document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Server/HTTPS/%EC%B2%A0%EC%88%98%EC%99%80-%EC%98%81%ED%9D%AC%EB%A5%BC-%ED%86%B5%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-https-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90/"},{"title":"5분안에 Node.js 로컬호스트에 HTTPS 적용하기","text":"들어가는 글,지난번에 올린 HTTPS의 기본 개념에 이어 이번에는 https를 로컬호스트에 적용하는 방법에 대해 알아보겠습니다.최근 개발하는 서비스에서 중요한 유저 정보 및 카드 정보 등을 위해 https를 개발해야 하는 상황이 생겼습니다.보통은 node.js서버에 https를 적용하지만 역시 나 개발을 하려면 로컬 적용이 불가피합니다.일반적인 웹사이트 또는 서버에서 사용할 https에서는 Certification Authority(CA)가 필요하지만, 본 포스트에서는 임의로 certificate을 발급하는 방법과 trust 방법에 대해 알아보겠습니다.Root SSL Certificateopenssl 을 이용하여 우선 rootCA.key 를 생성하여야 합니다.아래의 커맨드를 입력하여 생성 가능하며, 생성도중에 passphrase를 물어보게 되는데 추후 key를 사용할때마다 입력되어야 하는 값이므로 잊어버리지 않도록 합니다..openssl genrsa -des3 -out rootCA.key 2048passphrase에 대한 자세한 내용위에서 생성된 key를 이용하여 이번에는 pem파일을 만들어줍니다. 아래에는 1024일동안 사용가능하며 원하는 기간만큼 숫자를 조정하면 됩니다.openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.pemCertificate Trust 처리임의로 생성된 certificate이기 때문에 브라우저에서는 믿을 수 없다고 처리됩니다. 따라서 호스트역할을 하는 (여기서는 Mac)서버에서 trust 처리를 해주어야 합니다.mac의 keychain access에서 방금 생성한 certificate을 찾아 always trust 처리를 해줍니다.keychain access여기에 생성한 certificate을 import 해준다면 위와 같이 등록이 되며, 더블클릭 후 trust에서 always trust로 처리 합니다.자 이제 거의 다 왔습니다.사실 이 상태로 certificate을 서버에 적용하여 돌려보면 HTTPS로 동작은 합니다만 여전히 브라우저에서는 Not Secure라고 표시됩니다.로컬에서 사용할 수 있도록 domain 설정하기방금전 certificate을 생성하였던 디렉토리에서 아래와 같은 파일을 생성합니다.cnf파일은 키 생성시 입력하였던 옵션값을 파일로 만들어 매번 생성 시 일일이 값을 입력하지 않도록 해줍니다.server.csr.cnf1234567891011121314[req]default_bits = 2048prompt = nodefault_md = sha256distinguished_name = dn[dn]C=USST=StateNameL=CityNameO=OrganizationNameOU=OrganizationUnitNameemailAddress=helloworld@gililab.comCN = localhostv3.ext1234567authorityKeyIdentifier=keyid,issuerbasicConstraints=CA:FALSEkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEnciphermentsubjectAltName = @alt_names[alt_names]DNS.1 = localhost생성이 완료되었다면 아래의 커맨드로 server.key와 crt파일을 생성합니다.openssl req -new -sha256 -nodes -out server.csr -newkey rsa:2048 -keyout server.key -config &lt;( cat server.csr.cnf )openssl x509 -req -in server.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out server.crt -days 500 -sha256 -extfile v3.ext생성된 certificate node.js 서버에 적용하기생성된 server.key와 server.crt파일을 프로젝트 폴더에 위치 시킵니다.저는 프로젝트 폴더 하위에 private 이라는 폴더를 생성하여 server.key와 server.crt파일을 옮겨 넣었습니다.이제 ssl 데이터를 가지고 있는 config 파일을 생성하여 줍니다.ssl-config.js12345const path = require('path');const fs = require('fs'); exports.privateKey = fs.readFileSync(path.join(__dirname, '../private/server.key')).toString();exports.certificate = fs.readFileSync(path.join(__dirname, '../private/server.crt')).toString();시스템마다 다르겠지만 서버의 호스팅 옵션값을 가지고 있는 파일에 아래와 같이 적용합니다.loopback framework을 사용하는 저 같은 경우는 config.local.js 파일에 적용하였습니다.config.local.js123456{ restApiRoot: '/api', host: process.env.HOST || '0.0.0.0', port: process.env.PORT || 80, url: 'https://localhost',}마지막으로 server.js에 https를 적용시켜줍니다.!server.js12345678910111213141516171819202122232425...const https = require('https');const sslConfig = require('../config/ssl-config');...const options = { key: sslConfig.privateKey, cert: sslConfig.certificate, passphrase: 'abcd' // certificate을 생성하면서 입력하였던 passphrase 값};...const app = module.exports;app.start = function () { // start the web server const server = https.createServer(options, app); return server.listen(app.get('port'), () =&gt; { app.emit('started'); const baseUrl = app.get('url') + ':' + app.get('port'); console.info('Web server listening at: %s', baseUrl); if (app.get('loopback-component-explorer')) { const explorerPath = app.get('loopback-component-explorer').mountPath; console.info('Browse your REST API at %s%s', baseUrl, explorerPath); } });};정상적으로 적용 되었습니다!마치는 글이렇게 해서 https certificate 생성 부터 Node.js에 적용하는 방법까지 알아보았습니다.certificate을 생성하는 과정은 다소 복잡해 보일 수 있으나 서버에 적용시키는 방법은 생각보다 많이 간단합니다.임의로 생성한 certificate은 안전하지 않으며 절대 실제 production에서는 사용하지 말길 바랍니다.질문이나 피드백이 있다면 언제든지 알려주세요 !ReferenceThumbnailhttps://www.freecodecamp.org/news/how-to-get-https-working-on-your-local-development-environment-in-5-minutes-7af615770eechttps://support.comodo.com/index.php?/Knowledgebase/Article/View/364/17/what-is-a-passphrase-and-how-can-i-change-the-passphrase-on-my-private-key-filehttps://loopback.io/doc/en/lb2/Preparing-for-deployment.html#create-the-https-serverhttps://support.comodo.com/index.php?/Knowledgebase/Article/View/364/17/what-is-a-passphrase-and-how-can-i-change-the-passphrase-on-my-private-key-filehttps://stackoverflow.com/questions/47957538/preparing-loopback-to-use-ssl document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Server/HTTPS/5%EB%B6%84%EC%95%88%EC%97%90-node-js-%EB%A1%9C%EC%BB%AC%ED%98%B8%EC%8A%A4%ED%8A%B8%EC%97%90-https-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"var, let or const 무엇을 써야 할까 ?","text":"모든 예제 코드는 Github에서 확인 가능합니다.좋은 개발자란 무엇이라고 생각하시나요? 정답은 없겠지만 굳이 고르자면 코드를 간결하고 누가 봐도 작성자의 의도를 파악하기 쉽게 작성하는 개발자가 좋은 개발자라고 생각합니다.개발을 하다보면 종종 잠깐 쓰이다 말 변수인데 새로 선언하기도 귀찮고 특히나 이름 짓기가 너무 어려워서 그냥 하나의 변수를 다용도로 사용하고 싶어 지는 유혹(?)이 올 때가 있습니다. 하지만 이런 식의 변수 사용은 코드 작성자의 의도를 파악하기 어려울 뿐만 아니라 유지 보수에도 많은 시간과 비용이 들게 됩니다.따라서 이런 상황을 피하기 위해 자바스크립트 ES6에서 부터 제공되는 const 사용을 지향해야 합니다.constconst 변수의 특징은 처음 선언과 동시에 할당이 되면 재 할당이 불가능합니다.12345const number = 1;number = 2;Output:&gt;TypeError: Assignment to constant variable.const를 기능적으로 바라보았을 땐 단순히 변수의 재할당이 불가능하다 이지만 const를 사용한다는 뜻은 하나의 변수는 하나의 기능만 한다는 뜻을 내포하고 있습니다.다른 개발자가 const로 선언한 변수와 변수명을 보면 해당 변수는 하나의 목적을 위해 만들어졌다는 것이 파악되기 때문에 협업과 유지 보수에 있어서 많은 이점을 가져올 수 있습니다.const 예외한번 할당한 const의 경우 값의 수정이 불가능 하지만 예외는 존재합니다(변경이 안된다면서 이건 또 뭔 소리야 ?)12345678910111213const person = { name: 'Daniel', age: 28,};person.name = 'Andrew';const people = []people.push(person)console.log(person, people)Output:{ name: 'Andrew', age: 28 } [ { name: 'Andrew', age: 28 } ]integer, string 과 같은 JS의 기본 타입을 할당한 경우 변경이 불가능하지만 call by reference 를 사용하는 object나 array 같은 경우는 자유롭게 값을 수정할 수 있습니다.변수가 선언되고 나면 object나 array의 경우 변수는 해당 값의 메모리 주소를 가지고 있기 때문에 실제로 object내 값의 변화에 대해서는 관여하지 않게 됩니다.많은 분들이 const가 constant 또는 immutable이라고 생각하지만 위와 같은 성질 때문에 완전한 immutable이라고 말할 수는 없습니다.const 를 immutable로 사용하기ES5부터 지원되는 Object.freeze()를 이용하면 const object를 immutable변수 할당이 가능합니다.123const foo = Object.freeze({ 'bar': 27 });foo.bar = 42; // TypeError exceptionconsole.log(foo.bar);또는, immutable.js 와 같은 라이브러리를 통해 해결 가능합니다.그렇다면 var과 let의 차이는?항상 const 변수만 사용하면 좋겠지만, const를 사용할 수 없는 경우가 종종 오기도 합니다.for문 안에서 써야 하는 경우나, 복잡한 수학 공식을 계산하는 경우 등 변수 값이 계속해서 바뀌어야 하는 경우는 let을 사용하면 됩니다.var 과 let 둘 다 한번 선언하고 여러번 할당이 가능한 변수지만 둘의 가장 큰 차이점은 var은 function scoped 변수이고, let은 block scoped인 변수라는 점 입니다.예제112345678Input:console.log(x);var x=5;console.log(x);Output:undefined5예제1 var의 경우 변수가 선언이 되지 않았지만 호출이 된다면 현재 scope에서 해당 변수명이 존재하는지 찾고 없다면 다시 상위에서, 또 없다면 그 상위에서 찾으며 scope를 한 단계씩 올라가며 찾게 됩니다.예제21234567Input:console.log(x);let x=5;console.log(x);Output:ReferenceError: x is not defined하지만 예제2 let의 경우 선언과 할당이 이루어진 후에 해당 블록 내에서만 사용이 가능합니다.123456789101112for(var i=0; i&lt;10; i++){ console.log(i); // Output: 0, 1, 2, ... 9}console.log(i); // Output: 10const i = 1; // SyntaxError: Identifier 'i' has already been declaredfor(let j=0; j&lt;10; j++){ console.log(j); // Output: 0, 1, 2, ... 9}console.log(j); // ReferenceError: j is not definedconst j = 1; // 정상적으로 변수선언 가능var과 let 비교의 또다른 예제 입니다.첫번째 for문에서 선언된 var i 는 for문 밖에서도 사용이 가능하며 이후 i 를 선언한 경우 이미 선언된 변수라는 에러 메시지를 출력합니다.두번째 for문에서 선언된 let의 경우 for문 안에서는 정상 동작하지만 for문을 벗어난 시점 부터 존재하지 않는 변수로 처리됩니다.let을 사용한다는 뜻은 해당 변수의 값이 변경 될 수 있지만, 변수가 선언된 블록 내에서만 사용 한다는 뜻을 내포하고 있습니다. 따라서 const를 사용할 수 없는 상황이라면 let을 사용하는 것이 좋습니다.끝으로불가피한 상황이 아닌 이상 항상 const를 사용하는 것이 좋습니다. 추후에 다루어 볼 내용이지만, 함수형 프로그래밍 (Functional Programming) 형태로 코드를 작성하게 되는 경우 변수를 재할당해야 하는 대부분의 상황을 해결 할 수 있습니다. :)Referencehttps://medium.com/javascript-scene/javascript-es6-var-let-or-const-ba58b8dcde75https://github.com/goldbergyoni/nodebestpractices#-37-prefer-const-over-let-ditch-the-varhttps://www.geeksforgeeks.org/difference-between-var-and-let-in-javascript/https://mathiasbynens.be/notes/es6-const document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Javascript/General/var-let-or-const-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%8D%A8%EC%95%BC-%ED%95%A0%EA%B9%8C/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"Security","slug":"Security","link":"/tags/Security/"},{"name":"Wireshark","slug":"Wireshark","link":"/tags/Wireshark/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"}],"categories":[{"name":"Server","slug":"Server","link":"/categories/Server/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"HTTPS","slug":"Server/HTTPS","link":"/categories/Server/HTTPS/"},{"name":"General","slug":"Javascript/General","link":"/categories/Javascript/General/"}]}